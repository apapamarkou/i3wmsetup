#!/usr/bin/env python3

import sys
import os
import subprocess
import re
import json
import uuid
from PyQt6.QtWidgets import QApplication, QMainWindow, QVBoxLayout, QWidget, QLineEdit, QGridLayout, QLabel, QScrollArea, QPushButton, QHBoxLayout, QInputDialog, QDialog
from PyQt6.QtCore import Qt, QMimeData
from PyQt6.QtCore import QTimer
from PyQt6.QtGui import QPixmap, QDrag
from PyQt6.QtGui import QCursor
from PyQt6.QtGui import QIcon
from PyQt6.QtGui import QPainter, QColor, QFont
import pathlib

class AppButton(QWidget):
    def __init__(self, item_data, launcher=None):
        super().__init__()
        self.item_data = item_data
        self.launcher = launcher
        self.launched = False
        self.setFixedSize(120, 140)
        self.setAcceptDrops(True)
        
        layout = QVBoxLayout()
        layout.setContentsMargins(10, 10, 10, 10)
        layout.setSpacing(5)
        
        # Icon container
        icon_container = QWidget()
        icon_container.setFixedHeight(70)
        icon_layout = QVBoxLayout()
        icon_layout.setContentsMargins(0, 0, 0, 0)
        icon_layout.setAlignment(Qt.AlignmentFlag.AlignCenter)
        
        self.icon_label = QLabel()
        self.icon_label.setFixedSize(64, 64)
        self.icon_label.setAlignment(Qt.AlignmentFlag.AlignCenter)
        
        if item_data.get('type') == 'folder':
            # prefer theme icon, then fall back to local file, then emoji
            qicon = QIcon.fromTheme("folder")
            if not qicon.isNull():
                pix = qicon.pixmap(64, 64)
                self.icon_label.setPixmap(pix)
            else:
                folder_icon = self.launcher.find_icon("folder") if self.launcher else None
                if folder_icon and os.path.exists(folder_icon):
                    pixmap = QPixmap(folder_icon).scaled(64, 64, Qt.AspectRatioMode.KeepAspectRatio, Qt.TransformationMode.SmoothTransformation)
                    self.icon_label.setPixmap(pixmap)
                else:
                    # fallback pixmap when folder icon not found
                    self.icon_label.setPixmap(self._create_fallback_pixmap(64, "ðŸ“"))
        else:
            # Prefer an explicit file path first
            icon_path = item_data.get('icon')
            icon_name = item_data.get('icon_name')
            used = False
            if icon_path and os.path.exists(icon_path):
                pixmap = QPixmap(icon_path).scaled(64, 64, Qt.AspectRatioMode.KeepAspectRatio, Qt.TransformationMode.SmoothTransformation)
                self.icon_label.setPixmap(pixmap)
                used = True
            else:
                # try theme lookup (fromTheme) first â€” works for theme icons like Adwaita/Breeze
                if icon_name:
                    qicon = QIcon.fromTheme(icon_name)
                    if not qicon.isNull():
                        pix = qicon.pixmap(64, 64)
                        self.icon_label.setPixmap(pix)
                        used = True
                # fallback to filesystem search using find_icon
                if not used and icon_name and self.launcher:
                    resolved = self.launcher.find_icon(icon_name)
                    if resolved:
                        pixmap = QPixmap(resolved).scaled(64, 64, Qt.AspectRatioMode.KeepAspectRatio, Qt.TransformationMode.SmoothTransformation)
                        self.icon_label.setPixmap(pixmap)
                        used = True
                # as a last attempt, try basename from icon_path if present
                if not used and icon_path and self.launcher:
                    base = os.path.splitext(os.path.basename(icon_path))[0]
                    resolved = self.launcher.find_icon(base)
                    if resolved:
                        pixmap = QPixmap(resolved).scaled(64, 64, Qt.AspectRatioMode.KeepAspectRatio, Qt.TransformationMode.SmoothTransformation)
                        self.icon_label.setPixmap(pixmap)
                        used = True
            if not used:
                # generic fallback pixmap (uses first letter of app name)
                first = (item_data.get("name") or "?")[0].upper()
                self.icon_label.setPixmap(self._create_fallback_pixmap(64, first))
        
        icon_layout.addWidget(self.icon_label)
        icon_container.setLayout(icon_layout)
        
        # Name label
        display_name = item_data['name'][:20] + "..." if len(item_data['name']) > 20 else item_data['name']
        self.name_label = QLabel(display_name)
        self.name_label.setFixedHeight(50)
        self.name_label.setAlignment(Qt.AlignmentFlag.AlignCenter | Qt.AlignmentFlag.AlignTop)
        self.name_label.setWordWrap(True)
        self.name_label.setStyleSheet("color: white; font-size: 11px; background: transparent; border: none;")
        
        layout.addWidget(icon_container)
        layout.addWidget(self.name_label)
        self.setLayout(layout)
        
        self.setStyleSheet("""
            AppButton {
                background: transparent;
                border: none;
                border-radius: 8px;
            }
            AppButton:hover {
                background-color: rgba(255, 255, 255, 0.1);
            }
        """)
    
    def mousePressEvent(self, event):
        if event.button() == Qt.MouseButton.LeftButton:
            self.drag_start_position = event.pos()
    
    def mouseMoveEvent(self, event):
        if not (event.buttons() & Qt.MouseButton.LeftButton):
            return
        if ((event.pos() - self.drag_start_position).manhattanLength() < QApplication.startDragDistance()):
            return
        
        drag = QDrag(self)
        mimeData = QMimeData()
        mimeData.setText(f"item:{self.item_data['id']}")
        drag.setMimeData(mimeData)
        drag.exec(Qt.DropAction.MoveAction)
    
    def mouseReleaseEvent(self, event):
        if event.button() == Qt.MouseButton.LeftButton and hasattr(self, 'drag_start_position'):
            if (event.pos() - self.drag_start_position).manhattanLength() < QApplication.startDragDistance():
                self.launch_item()
    
    def dragEnterEvent(self, event):
        if event.mimeData().hasText() and event.mimeData().text().startswith("item:"):
            event.acceptProposedAction()
    
    def dropEvent(self, event):
        dropped_id = event.mimeData().text().replace("item:", "")
        if dropped_id != self.item_data['id'] and self.launcher:
            # If we're in a folder and dropping on an app, remove from folder
            if self.launcher.in_folder and self.item_data.get('type') != 'folder':
                self.launcher.remove_from_folder(dropped_id)
            elif self.item_data.get('type') == 'folder':
                self.launcher.add_to_folder(self.item_data['id'], dropped_id)
            else:
                self.launcher.create_folder(self.item_data['id'], dropped_id)
            event.acceptProposedAction()
    
    def launch_item(self):
        if self.item_data.get('type') == 'folder':
            self.launcher.show_folder_contents(self.item_data['id'])
        else:
            if self.launched:
                return
            self.launched = True
            try:
                subprocess.Popen(self.item_data['exec'], shell=True)
            except:
                pass
            QApplication.quit()

class AppLauncher(QMainWindow):
    def __init__(self):
        super().__init__()
        self.config_file = os.path.expanduser("~/.config/ylauncher.json")
        self.data = self.load_data()
        # Make sure Qt can find icons in common system/user locations
        try:
            extra_paths = ["/usr/share/icons", "/usr/share/pixmaps", os.path.expanduser("~/.local/share/icons")]
            existing = QIcon.themeSearchPaths()
            # prepend to avoid duplicates
            for p in extra_paths:
                if p not in existing and pathlib.Path(p).exists():
                    existing.append(p)
            # add any top-level themes under /usr/share/icons (helps find AdwaitaLegacy etc.)
            icons_root = pathlib.Path("/usr/share/icons")
            if icons_root.exists():
                for sub in icons_root.iterdir():
                    if sub.is_dir() and str(sub) not in existing:
                        existing.append(str(sub))
            QIcon.setThemeSearchPaths(existing)
            # ensure a reasonable theme is selected so QIcon.fromTheme can find icons (hicolor is a safe fallback)
            try:
                QIcon.setThemeName("hicolor")
            except Exception:
                pass
        except Exception:
            pass

        # UI state defaults (must exist before any event handlers run)
        self.filtered_items = []
        self.selected_index = 0
        self.cols = 8
        self.app_buttons = []
        self.in_folder = False
        self.current_folder_id = None
        self.last_selected_folder_id = None

        # Resolve missing icon paths at startup: prefer find_icon(icon_name) then leave icon_name for QIcon.fromTheme fallback
        updated = False
        for app_id, app in self.data.get("applications", {}).items():
            icon_path = app.get("icon")
            icon_name = app.get("icon_name")
            if icon_path and os.path.exists(icon_path):
                continue
            resolved = None
            if icon_name:
                resolved = self.find_icon(icon_name)
            if not resolved and icon_path:
                # maybe icon_path was actually an icon basename (with ext or without)
                base = os.path.splitext(os.path.basename(icon_path))[0]
                resolved = self.find_icon(base)
                if not icon_name:
                    app["icon_name"] = base
            if resolved:
                app["icon"] = resolved
                updated = True
        if updated:
            # save resolved paths back to config
            self.save_data(self.data)

        # Initialize UI regardless of whether we updated icons
        self.init_ui()
        self.refresh_display()
        self.setFocus()
        
    def init_ui(self):
        self.setWindowTitle("Application Launcher")
        self.setWindowFlags(Qt.WindowType.FramelessWindowHint | Qt.WindowType.WindowStaysOnTopHint)
        self.setFocusPolicy(Qt.FocusPolicy.StrongFocus)
        self.showFullScreen()
        
        self.setStyleSheet("""
            QMainWindow { background-color: #1e1e1e; }
            QLineEdit { 
                background-color: #2d2d2d; 
                color: #ffffff; 
                border: 2px solid #404040;
                border-radius: 8px;
                padding: 12px;
                font-size: 18px;
            }
            QPushButton {
                background-color: #404040;
                color: white;
                border: none;
                border-radius: 8px;
                padding: 8px 16px;
                font-size: 14px;
            }
            QPushButton:hover {
                background-color: #505050;
            }
            QScrollArea {
                background-color: #1e1e1e;
                border: none;
            }
        """)
        
        central_widget = QWidget()
        self.setCentralWidget(central_widget)
        
        main_layout = QVBoxLayout()
        main_layout.setContentsMargins(100, 50, 100, 50)
        main_layout.setSpacing(30)
        
        # Header with title and edit button
        self.header_widget = QWidget()
        header_layout = QHBoxLayout()
        header_layout.setContentsMargins(0, 0, 0, 0)
        
        self.title_label = QLabel("Applications")
        self.title_label.setStyleSheet("color: white; font-size: 24px; font-weight: bold;")
        
        self.edit_button = QPushButton("Edit")
        self.edit_button.clicked.connect(self.edit_folder_name)
        self.edit_button.hide()
        
        header_layout.addWidget(self.title_label)
        header_layout.addStretch()
        header_layout.addWidget(self.edit_button)
        self.header_widget.setLayout(header_layout)
        
        main_layout.addWidget(self.header_widget)
        
        # Search bar
        self.search_bar = QLineEdit()
        self.search_bar.setPlaceholderText("Type to search applications...")
        self.search_bar.textChanged.connect(self.filter_items)
        self.search_bar.returnPressed.connect(self.launch_selected)
        self.search_bar.setMaximumWidth(600)
        
        search_widget = QWidget()
        search_layout = QVBoxLayout()
        search_layout.addWidget(self.search_bar, alignment=Qt.AlignmentFlag.AlignCenter)
        search_widget.setLayout(search_layout)
        
        main_layout.addWidget(search_widget)
        
        # Grid area
        self.scroll_area = QScrollArea()
        self.scroll_area.setWidgetResizable(True)
        self.scroll_area.setHorizontalScrollBarPolicy(Qt.ScrollBarPolicy.ScrollBarAlwaysOff)
        self.scroll_area.setVerticalScrollBarPolicy(Qt.ScrollBarPolicy.ScrollBarAsNeeded)
        
        self.grid_widget = QWidget()
        self.grid_layout = QGridLayout()
        # allow dropping onto the grid area (e.g. drop to remove from folder)
        self.grid_widget.setAcceptDrops(True)
        # bind drag/drop handlers to the grid widget
        self.grid_widget.dragEnterEvent = self.grid_drag_enter_event
        self.grid_widget.dropEvent = self.grid_drop_event
        self.grid_layout.setSpacing(15)
        self.grid_widget.setLayout(self.grid_layout)
        
        self.scroll_area.setWidget(self.grid_widget)
        main_layout.addWidget(self.scroll_area)
        
        central_widget.setLayout(main_layout)
        
    def load_data(self):
        if os.path.exists(self.config_file):
            try:
                with open(self.config_file, 'r') as f:
                    return json.load(f)
            except:
                pass
        
        # Build initial data from desktop files
        data = {"applications": {}, "folders": {}}
        
        desktop_dirs = [
            "/usr/share/applications",
            os.path.expanduser("~/.local/share/applications")
        ]
        
        for desktop_dir in desktop_dirs:
            if os.path.exists(desktop_dir):
                try:
                    for file in os.listdir(desktop_dir):
                        if file.endswith('.desktop'):
                            app_info = self.parse_desktop_file(os.path.join(desktop_dir, file))
                            if app_info:
                                app_id = str(uuid.uuid4())
                                data["applications"][app_id] = {
                                    "id": app_id,
                                    "name": app_info["name"],
                                    "exec": app_info["exec"],
                                    "icon": app_info["icon"],
                                    "icon_name": app_info.get("icon_name"),
                                    "folderId": None
                                }
                except PermissionError:
                    continue
        
        self.save_data(data)
        return data
    
    def parse_desktop_file(self, filepath):
        try:
            with open(filepath, 'r', encoding='utf-8', errors='ignore') as f:
                lines = f.readlines()
            
            name = None
            exec_cmd = None
            icon = None
            no_display = False
            
            for line in lines:
                line = line.strip()
                if not line or line.startswith('#') or line.startswith('['):
                    continue
                    
                if '=' not in line:
                    continue
                    
                key, value = line.split('=', 1)
                key = key.strip()
                value = value.strip()
                
                if key == 'Name' and not name:
                    name = value
                elif key == 'Exec' and not exec_cmd:
                    exec_cmd = value
                elif key == 'Icon' and not icon:
                    icon = value
                elif key == 'NoDisplay':
                    no_display = value.lower() in ['true', '1', 'yes']
            
            if name and exec_cmd and not no_display:
                exec_cmd = re.sub(r'%[fFuUick]', '', exec_cmd).strip()
                # preserve original icon name and also try to resolve a filesystem path
                icon_path = self.find_icon(icon) if icon else None
                return {'name': name, 'exec': exec_cmd, 'icon': icon_path, 'icon_name': icon}
        except Exception:
            pass
        return None
    
    def find_icon(self, icon_name):
        if not icon_name:
            return None

        # If it's already an absolute path
        if os.path.isabs(icon_name) and os.path.exists(icon_name):
            return icon_name

        # normalize
        icon_base = os.path.splitext(os.path.basename(icon_name))[0].lower()

        # Common extensions to try
        extensions = [".png", ".svg", ".xpm", ""]

        # Quick check in a few specific directories (keeps original behaviour)
        icon_dirs = [
            "/usr/share/icons/hicolor/64x64/apps",
            "/usr/share/icons/hicolor/48x48/apps",
            "/usr/share/icons/hicolor/scalable/apps",
            "/usr/share/pixmaps"
        ]
        for icon_dir in icon_dirs:
            if os.path.exists(icon_dir):
                for ext in extensions:
                    icon_path = os.path.join(icon_dir, icon_base + ext)
                    if os.path.exists(icon_path):
                        return icon_path

        # Broader recursive search in typical icon roots (covers theme subdirs like 128x128/apps, scalable, etc.)
        search_roots = [
            "/usr/share/icons",
            "/usr/share/pixmaps",
            os.path.expanduser("~/.local/share/icons"),
            "/usr/share/icons/hicolor"
        ]
        for root in search_roots:
            if not os.path.exists(root):
                continue
            for dirpath, dirnames, filenames in os.walk(root):
                for fname in filenames:
                    name, ext = os.path.splitext(fname)
                    lname = name.lower()
                    if ext.lower() in [".png", ".svg", ".xpm"]:
                        # exact match (basename or filename)
                        if fname == icon_name or lname == icon_base:
                            return os.path.join(dirpath, fname)
                        # substring / variant matches: pacseek, nm-device-wireless, network-wired, suffixes like "-symbolic"
                        if icon_base in lname or lname.startswith(icon_base + "-") or lname.endswith("-" + icon_base):
                            return os.path.join(dirpath, fname)

        # Last resort: try desktop-like icon name with extensions in the pixmaps folder
        pixmaps = ["/usr/share/pixmaps", os.path.expanduser("~/.local/share/icons")]
        for pdir in pixmaps:
            if os.path.exists(pdir):
                for ext in extensions:
                    candidate = os.path.join(pdir, icon_base + ext)
                    if os.path.exists(candidate):
                        return candidate

        # Not found
        return None
    
    def save_data(self, data=None):
        if data is None:
            data = self.data
        try:
            os.makedirs(os.path.dirname(self.config_file), exist_ok=True)
            with open(self.config_file, 'w') as f:
                json.dump(data, f, indent=2)
        except Exception:
            pass
    
    def refresh_display(self):
        if self.in_folder:
            folder = self.data["folders"][self.current_folder_id]
            self.title_label.setText(folder["name"])
            self.edit_button.show()
            self.filtered_items = [self.data["applications"][app_id] for app_id in folder["appIds"]]
        else:
            self.title_label.setText("Applications")
            self.edit_button.hide()
            # Show apps not in folders and all folders
            items = []
            for app in self.data["applications"].values():
                if app["folderId"] is None:
                    items.append(app)
            for folder in self.data["folders"].values():
                items.append({"id": folder["id"], "name": folder["name"], "type": "folder"})
            self.filtered_items = sorted(items, key=lambda x: x["name"].lower())
        
        self.populate_grid()
    
    def populate_grid(self):
        for i in reversed(range(self.grid_layout.count())):
            self.grid_layout.itemAt(i).widget().setParent(None)
        self.app_buttons = []
        
        for i, item in enumerate(self.filtered_items):
            row = i // self.cols
            col = i % self.cols
            
            app_button = AppButton(item, self)
            self.grid_layout.addWidget(app_button, row, col)
            self.app_buttons.append(app_button)
        
        if self.app_buttons:
            self.highlight_button(0)
    
    def highlight_button(self, index):
        for i, btn in enumerate(self.app_buttons):
            item = self.filtered_items[i]
            if item.get('type') == 'folder':
                btn.setStyleSheet("""
                    QWidget {
                        background: transparent;
                        border: 2px solid #888888;
                        border-radius: 8px;
                    }
                    QWidget:hover {
                        background-color: rgba(255, 255, 255, 0.1);
                    }
                """)
            else:
                btn.setStyleSheet("""
                    QWidget {
                        background: transparent;
                        border: none;
                        border-radius: 8px;
                    }
                    QWidget:hover {
                        background-color: rgba(255, 255, 255, 0.1);
                    }
                """)
        
        if 0 <= index < len(self.app_buttons):
            self.app_buttons[index].setStyleSheet("""
                QWidget {
                    background-color: rgba(128, 128, 128, 0.6);
                    border: 2px solid #888888;
                    border-radius: 8px;
                }
                QWidget:hover {
                    background-color: rgba(128, 128, 128, 0.7);
                }
            """)
            self.selected_index = index
    
    def filter_items(self):
        query = self.search_bar.text().lower()
        if query:
            self.filtered_items = [item for item in self.filtered_items if query in item["name"].lower()]
        else:
            self.refresh_display()
        self.selected_index = 0
        self.populate_grid()
    
    def create_folder(self, app1_id, app2_id):
        folder_id = str(uuid.uuid4())
        folder_name = "App Folder"
        
        self.data["folders"][folder_id] = {
            "id": folder_id,
            "name": folder_name,
            "appIds": [app1_id, app2_id]
        }
        
        self.data["applications"][app1_id]["folderId"] = folder_id
        self.data["applications"][app2_id]["folderId"] = folder_id
        
        self.save_data()
        self.refresh_display()
    
    def add_to_folder(self, folder_id, app_id):
        if folder_id in self.data["folders"] and app_id in self.data["applications"]:
            self.data["folders"][folder_id]["appIds"].append(app_id)
            self.data["applications"][app_id]["folderId"] = folder_id
            self.save_data()
            self.refresh_display()
    
    def remove_from_folder(self, app_id):
        if app_id in self.data["applications"]:
            app = self.data["applications"][app_id]
            if app["folderId"]:
                folder_id = app["folderId"]
                if folder_id in self.data["folders"]:
                    self.data["folders"][folder_id]["appIds"].remove(app_id)
                    app["folderId"] = None
                    self.save_data()
                    self.refresh_display()
    
    def show_folder_contents(self, folder_id):
        self.last_selected_folder_id = folder_id
        self.in_folder = True
        self.current_folder_id = folder_id
        self.refresh_display()
    
    def edit_folder_name(self):
        if self.current_folder_id:
            # open the editor (parented to launcher), modal and full-screen
            editor = FolderNameEditor(self.data["folders"][self.current_folder_id]["name"], self)
            editor.setWindowModality(Qt.WindowModality.ApplicationModal)
            result = editor.exec()
            # schedule a short restore of fullscreen/window state â€” helps i3 re-tile back to fullscreen
            def _restore_fullscreen():
                try:
                    self.showFullScreen()
                    # ensure the Qt fullscreen state bit is set
                    self.setWindowState(self.windowState() | Qt.WindowState.WindowFullScreen)
                    self.raise_()
                    self.activateWindow()
                    self.setFocus()
                except Exception:
                    pass
            QTimer.singleShot(50, _restore_fullscreen)
            if result == QDialog.DialogCode.Accepted:
                new_name = editor.get_name()
                if new_name.strip():
                    self.data["folders"][self.current_folder_id]["name"] = new_name.strip()
                    self.save_data()
                    self.refresh_display()
    
    def launch_selected(self):
        if 0 <= self.selected_index < len(self.app_buttons):
            self.app_buttons[self.selected_index].launch_item()
    
    def keyPressEvent(self, event):
        key = event.key()
        if key == Qt.Key.Key_Escape:
            if self.in_folder:
                self.in_folder = False
                self.current_folder_id = None
                self.refresh_display()
                # Find and select the last opened folder
                if self.last_selected_folder_id:
                    for i, item in enumerate(self.filtered_items):
                        if item.get('id') == self.last_selected_folder_id:
                            self.highlight_button(i)
                            break
            else:
                self.close()
        elif key == Qt.Key.Key_Return or key == Qt.Key.Key_Enter:
            self.launch_selected()
        elif key == Qt.Key.Key_Right and self.app_buttons:
            if self.selected_index < len(self.app_buttons) - 1:
                self.highlight_button(self.selected_index + 1)
        elif key == Qt.Key.Key_Left and self.app_buttons:
            if self.selected_index > 0:
                self.highlight_button(self.selected_index - 1)
        elif key == Qt.Key.Key_Down and self.app_buttons:
            new_index = self.selected_index + self.cols
            if new_index < len(self.app_buttons):
                self.highlight_button(new_index)
        elif key == Qt.Key.Key_Up and self.app_buttons:
            new_index = self.selected_index - self.cols
            if new_index >= 0:
                self.highlight_button(new_index)
        elif key == Qt.Key.Key_Tab:
            self.search_bar.setFocus()
        elif event.text().isprintable():
            self.search_bar.setFocus()
            self.search_bar.setText(self.search_bar.text() + event.text())
        else:
            super().keyPressEvent(event)
    
    def mousePressEvent(self, event):
        # Determine the widget under the cursor (global-aware)
        widget = QApplication.widgetAt(QCursor.pos())

        # Walk up parents to see if we clicked an interactive element
        clicked_interactive = False
        w = widget
        while w is not None:
            if isinstance(w, AppButton) or w is self.title_label or w is self.edit_button or w is self.search_bar:
                clicked_interactive = True
                break
            w = w.parent()

        if not clicked_interactive:
            # click on empty area
            if self.in_folder:
                # return from folder to main view
                self.in_folder = False
                self.current_folder_id = None
                self.refresh_display()
            else:
                # in main -> exit
                self.close()
        else:
            super().mousePressEvent(event)

    # Drag enter handler for the empty grid area
    def grid_drag_enter_event(self, event):
        if event.mimeData().hasText() and event.mimeData().text().startswith("item:"):
            event.acceptProposedAction()
        else:
            event.ignore()

    # Drop handler for the empty grid area â€” dropping there removes an app from the current folder
    def grid_drop_event(self, event):
        if event.mimeData().hasText() and event.mimeData().text().startswith("item:"):
            dropped_id = event.mimeData().text().replace("item:", "")
            # If we're viewing a folder, dropping on the empty grid should remove the app from that folder
            if self.in_folder:
                self.remove_from_folder(dropped_id)
                event.acceptProposedAction()
                return
        event.ignore()
    
class FolderNameEditor(QDialog):
    def __init__(self, current_name, parent=None):
        super().__init__(parent)
        self.current_name = current_name
        # make this a frameless, application-modal full-screen editor (avoid WindowStaysOnTop which can upset tiling WMs)
        self.setWindowFlags(Qt.WindowType.FramelessWindowHint | Qt.WindowType.Dialog)
        self.setWindowModality(Qt.WindowModality.ApplicationModal)
        self.showFullScreen()
        
        self.setStyleSheet("""
            QDialog { background-color: #1e1e1e; }
            QLineEdit { 
                background-color: #2d2d2d; 
                color: #ffffff; 
                border: 2px solid #404040;
                border-radius: 8px;
                padding: 20px;
                font-size: 24px;
            }
            QLabel {
                color: white;
                font-size: 18px;
            }
        """)
        
        layout = QVBoxLayout()
        layout.setAlignment(Qt.AlignmentFlag.AlignCenter)
        layout.setSpacing(30)
        
        title = QLabel("Edit Folder Name")
        title.setAlignment(Qt.AlignmentFlag.AlignCenter)
        title.setStyleSheet("font-size: 32px; font-weight: bold;")
        
        self.name_input = QLineEdit(current_name)
        self.name_input.setMaximumWidth(600)
        self.name_input.selectAll()
        self.name_input.returnPressed.connect(self.accept)
        
        instruction = QLabel("Press Enter to save, Escape to cancel")
        instruction.setAlignment(Qt.AlignmentFlag.AlignCenter)
        
        layout.addWidget(title)
        layout.addWidget(self.name_input, alignment=Qt.AlignmentFlag.AlignCenter)
        layout.addWidget(instruction)
        
        self.setLayout(layout)
        self.name_input.setFocus()
    
    def get_name(self):
        return self.name_input.text()
    
    def keyPressEvent(self, event):
        if event.key() == Qt.Key.Key_Escape:
            self.reject()
        else:
            super().keyPressEvent(event)
    
    def mousePressEvent(self, event):
        # Click anywhere that's not the input or title should close the editor (return to folder)
        widget = QApplication.widgetAt(QCursor.pos())
        w = widget
        clicked_input = False
        while w is not None:
            if w is self.name_input:
                clicked_input = True
                break
            w = w.parent()

        if not clicked_input:
            self.reject()
        else:
            super().mousePressEvent(event)

    def _create_fallback_pixmap(self, size=64, text=None):
        """Return a simple fallback QPixmap with centered text/glyph."""
        pix = QPixmap(size, size)
        pix.fill(QColor("#2d2d2d"))
        painter = QPainter(pix)
        painter.setRenderHint(QPainter.RenderHint.Antialiasing)
        pen = QColor("#FFFFFF")
        painter.setPen(pen)
        font = QFont()
        font.setBold(True)
        # pick a font size relative to the pixmap
        font.setPointSize(int(size * 0.5))
        painter.setFont(font)
        if not text:
            text = "?"
        painter.drawText(pix.rect(), Qt.AlignmentFlag.AlignCenter, text)
        painter.end()
        return pix

if __name__ == "__main__":
    # create the QApplication before any QWidget
    app = QApplication(sys.argv)
    launcher = AppLauncher()
    launcher.show()
    sys.exit(app.exec())